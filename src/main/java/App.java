import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;
import org.netbeans.lib.profiler.heap.*;
import java.io.*;
import java.util.List;
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {
	
	@Option(name="-hprof", usage="The filesystem path pointing to the hprof file to dump", required=true)
	private String hprofPath;
	
	@Option(name="-class", usage="The full class name of the instances to dump", required=true)
	private String classToDump;
	
	@Option(name="-delimeter", usage="String that separates all the columns", required=false)
	private String delimeter = "\t";
	
	@Option(name="-disableHeader", usage="Do not print the header column of the name of the fields", required=false)
	private boolean disableHeader = false;	
	
    public static void main(String[] args) throws IOException {
    	App bean = new App();
        CmdLineParser parser = new CmdLineParser(bean);
        try {
                parser.parseArgument(args);
                bean.run();
        } catch (CmdLineException e) {
            // handling of wrong arguments
            System.err.println(e.getMessage());
            parser.printUsage(System.err);
        }
    }
    
    public void run() throws FileNotFoundException, IOException {
	    Heap heap = HeapFactory.createHeap(new File(hprofPath));
	    
	    JavaClass javaClass = heap.getJavaClassByName(classToDump);
	    
	    boolean needToWriteHeader = !disableHeader;
	    
	    // Unfortunately, the library does not use a generic
	    // but the javadoc guarentees it's a List on Instance. This also prevent us from inline
	    // the statement in the loop.
	    @SuppressWarnings("unchecked")  
		List<Instance> instances = javaClass.getInstances();
	    for(Instance instance : instances) {
	    	@SuppressWarnings("unchecked") // same deal here
	    	List<FieldValue> fields = instance.getFieldValues();
	    	if(needToWriteHeader) {
	    		writeHeader(heap, fields);
	        	needToWriteHeader = false;
	    	}
	    	
	    	writeFields(heap, fields);
	    }
    }
    
    private void writeHeader(Heap heap, List<FieldValue> fields) {
		boolean first = true;
    	for(FieldValue field : fields) {
    		if(!first) {
    			System.out.print(delimeter);
    		}
    		
    		if ("object".equals(field.getField().getType().getName())) {
    			Instance fieldInstance =getInstanceFromFieldValue(field);
    			System.out.print(fieldInstance.getJavaClass().getName());
    		} else {
    			System.out.print(field.getField().getType().getName());
    		}
    		System.out.print(":");
    		System.out.print(field.getField().getName());
    		
    		first = false;
    	}
    	System.out.println();
    }
    
    private void writeFields(Heap heap, List<FieldValue> fields) {
    	boolean first = true;
    	for(FieldValue field : fields) {
    		if(!first) {
    			System.out.print(delimeter);
    		}

    		printFieldValue(heap, field);
    		
    		first = false;
    	}
    	System.out.println();
    }
    
    private void printFieldValue(Heap heap, FieldValue field) {
    	if ("object".equals(field.getField().getType().getName())) {
			Instance fieldInstance = getInstanceFromFieldValue(field);
			if("java.lang.String".equals(fieldInstance.getJavaClass().getName())) {
				System.out.print(extractString(fieldInstance));
			} else {
	    		System.out.print(field.getField().getDeclaringClass().getName() + ":");
				System.out.print(field.getValue());
			}
		} else { // primitive types
			System.out.print(field.getValue());
		}
    }
    
    private String extractString(Instance stringInstance) {
    	return "";
    }
    
    private Instance getInstanceFromFieldValue(FieldValue fieldValue) {
    	return ((ObjectFieldValue)fieldValue).getInstance();
    }
    
    private Instance getInstanceFromFieldValueOldMethod(Heap heap, FieldValue fieldValue) {
    	return  heap.getInstanceByID(Long.parseLong(fieldValue.getValue()));
    }
}
